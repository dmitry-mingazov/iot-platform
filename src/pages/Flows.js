import { Typography } from "@mui/material";
import React, { useContext, useEffect, useState } from "react";
import { makeStyles } from "@mui/styles";
import FlowsTable from "../components/FlowsTable";
import { CircularProgress, Box } from "@mui/material";
import { useNodeRed } from "../components/context/NodeRedContext";
import { AuthContext } from "../components/context/AuthContext";
import DeviceService from "../services/DeviceService";

//Styles
const useStyles = makeStyles({
  containerColumn: {
    display: "flex",
    flexDirection: "column",
    height: "100%",
  },
  title: {
    marginTop: 20,
    marginLeft: 60,
    fontWeight: "bold",
  },
  grid: {
    alignItems: "center",
    justifyContent: "center",
    display: "flex",
    height: "100%",
    marginRight: "90px",
    marginLeft: "90px",
    marginTop: "45px",
    marginBottom: "65px",
  },
});

function Flows() {
  const classes = useStyles();
  const { flows, updateFlows, nodeRedUrl } = useNodeRed();
  const { isTokenReady } = useContext(AuthContext);
  const [devices, setDevices] = useState([]);
  const [isDevicesReady, setDevicesReady] = useState(false);
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(false);

  const mapFlowsToRows = (flows) => {
    const flowsTemp = [...flows];
    const _flows = {};

    const getRow = (id) => {
      if (!_flows[id]) {
        _flows[id] = {id, devices: {}};
      }
      return _flows[id]
    }

    flowsTemp.forEach(flowObj => {
      let row;
      const {id, label, z, info, type} = flowObj;
      switch (type) {
        case 'tab':
          row = getRow(id);
          row.flow = label;
          break;
        case 'comment':
          row = getRow(z);
          row.info = info;
          break;
        default:
          // if doesn't have a parent or its Id isn't formatted
          // in a way that indicates was generated by an export
          // (regex: any char except '|' + '|' + any char)
          if (!z || !id.match(/[^\|]*\|.*/)) {
            break;
          }
          const deviceId = id.split('|')[0];
          const device = devices.find(_device => _device._id === deviceId);
          if (device) {
            row = getRow(z);
            row.devices[deviceId] = device.name;
          }
      }
    });

    const devicesToStr = (devices) => {
      let str = '';
      Object.values(devices).forEach(device => {
        str = str ? str + ', ' + device : device;
      });
      return str;
    }

    const rows = Object.values(_flows)
      .map(({id, flow, info, devices}) => ({
          flow,
          id,
          comment: info,
          devices: devicesToStr(devices)
      }));

    return rows;
  };

  useEffect(() => {
    if (nodeRedUrl) {
      updateFlows();
    }
  }, [nodeRedUrl]);

  useEffect(() => {
    if (isTokenReady) {
      DeviceService.getDevices().then(_devices => {
        setDevices(_devices);
        setDevicesReady(true);
      })
    }
  }, [isTokenReady])

  useEffect(() => {
    if (flows.length > 0 && isDevicesReady) {
      setLoading(true);
      const rows = mapFlowsToRows(flows);
      setRows(rows);
      setLoading(false);
    }
  }, [flows, isDevicesReady]);

  return (
    <Box className={classes.containerColumn}>
      <Typography className={classes.title} variant="h4">
        Flows
      </Typography>
      <Box className={classes.grid}>
        {loading ? (
          <Box
            alignItems="center"
            justifyContent="center"
            display="flex"
            minHeight="100%"
          >
            <CircularProgress size={35} />
          </Box>
        ) : (
          <FlowsTable rows={rows} />
        )}
      </Box>
    </Box>
  );
}

export default Flows;
